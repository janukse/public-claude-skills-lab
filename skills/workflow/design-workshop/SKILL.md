---
name: design-workshop
description: 범용 소프트웨어 설계 워크플로우. 설계 유형 자동 감지, 전문가 패널 검토, 단계별 가이드, 설계 문서 생성, feature-planner 연계 지원
argument-hint: "<설계 주제> [--type architecture|api|database|uiux|system] [--with-plan] [--parallel]"
---

# Design Workshop

## 목적

소프트웨어 설계를 체계적으로 진행하기 위한 범용 워크플로우. 요구사항 분석부터 설계 문서 생성까지 전문가 패널의 다관점 검토를 포함한 단계별 설계 프로세스를 제공한다.

- 설계 유형(아키텍처, API, DB, UI/UX, 시스템)을 자동 감지하고 유형에 맞는 설계 템플릿 적용
- 설계 유형별 전문가 페르소나가 다각도로 설계를 검토하여 맹점 제거
- 요구사항 분석 → 설계 초안 → 패널 검토 → 확정 → 문서화의 체계적 워크플로우
- ADR(Architecture Decision Record) 및 설계 명세서 등 표준 형식 문서 자동 생성
- feature-planner 스킬과 연계하여 설계 결과 기반 작업 지시서(plan) 자동 생성 지원

## 사용법

```
/design-workshop 사용자 인증 시스템 재설계
/design-workshop REST API v2 설계 --type api
/design-workshop 주문 도메인 DB 스키마 설계 --type database --adr
/design-workshop 대시보드 컴포넌트 설계 --type uiux --personas "UI 디자이너, 프론트엔드 시니어, 접근성 전문가"
/design-workshop 알림 시스템 아키텍처 --preset arch --parallel --with-plan
/design-workshop 결제 모듈 설계 --output docs/designs/payment/ --adr --with-plan
```

### 옵션

| 옵션 | 설명 |
|------|------|
| `<설계 주제>` | 설계할 기능 또는 시스템 설명 (필수) |
| `--type <유형>` | 설계 유형 강제 지정: `architecture`, `api`, `database`, `uiux`, `system` |
| `--personas "A, B, C"` | 쉼표로 구분한 커스텀 검토 페르소나 목록 |
| `--preset <이름>` | 프리셋 검토 패널 사용 (아래 표 참고) |
| `--parallel` | 에이전트 팀을 사용한 병렬 검토 (기본: 순차) |
| `--with-plan` | 설계 완료 후 feature-planner로 작업 지시서 자동 생성 |
| `--output <경로>` | 설계 문서 저장 경로 (기본: `docs/designs/`) |
| `--adr` | ADR(Architecture Decision Record) 문서도 함께 생성 |

### 프리셋 검토 패널

| 프리셋 | 페르소나 구성 | 적합한 설계 |
|--------|--------------|-------------|
| `arch` | 시스템 아키텍트, 보안 전문가, DevOps 엔지니어, 성능 엔지니어 | 시스템/서비스 아키텍처 설계 |
| `api` | API 설계 전문가, 프론트엔드 소비자, 보안 전문가, DX 엔지니어 | REST/GraphQL API 설계 |
| `db` | DBA, 데이터 모델러, 백엔드 엔지니어, 성능 전문가 | DB 스키마, 데이터 모델 설계 |
| `frontend` | UI/UX 디자이너, 프론트엔드 시니어, 접근성 전문가, 성능 전문가 | UI 컴포넌트, 화면 설계 |
| `fullstack` | 풀스택 시니어, 보안 전문가, DevOps 엔지니어, QA 리드 | 전체 기능 통합 설계 |

## Workflow

### Step 1: 요구사항 분석

#### 1a: 설계 주제 파악

사용자가 제공한 설계 주제를 분석하고, 프로젝트 코드베이스를 탐색하여 기존 구조를 파악한다.

`Glob`과 `Grep`으로 관련 코드, 설정 파일, 기존 문서를 탐색한다:
- 프로젝트의 디렉토리 구조와 주요 모듈
- 기존 아키텍처 패턴과 기술 스택
- 관련 도메인의 현재 구현 상태
- 기존 설계 문서나 ADR이 있는지 확인

#### 1b: 설계 유형 감지

`--type`이 지정되지 않은 경우, 설계 주제와 코드베이스 분석 결과를 기반으로 설계 유형을 자동 감지한다.

| 설계 유형 | 감지 키워드/패턴 | 설명 |
|-----------|----------------|------|
| `architecture` | 시스템, 서비스, 모듈, 마이크로서비스, 레이어, 인프라 | 시스템/서비스 수준의 구조 설계 |
| `api` | API, 엔드포인트, REST, GraphQL, gRPC, 라우트 | API 인터페이스 설계 |
| `database` | DB, 스키마, 테이블, ERD, 마이그레이션, 모델 | 데이터베이스/데이터 모델 설계 |
| `uiux` | UI, UX, 컴포넌트, 화면, 페이지, 대시보드, 폼 | UI/UX 및 프론트엔드 설계 |
| `system` | 연동, 통합, 파이프라인, 워크플로우, 배치 | 시스템 간 연동/통합 설계 |

**감지 결과를 사용자에게 표시:**

```markdown
## 요구사항 분석 결과

| 항목 | 내용 |
|------|------|
| 설계 주제 | <주제> |
| 감지된 설계 유형 | <유형> |
| 프로젝트 기술 스택 | <감지된 스택> |
| 관련 기존 코드 | <관련 파일/모듈 목록> |
| 기존 설계 문서 | <있으면 경로, 없으면 "없음"> |
```

`AskUserQuestion`으로 확인:
- "분석 결과가 맞습니다. 계속 진행" -- Step 2로 진행
- "설계 유형을 변경합니다: <유형>" -- 유형 변경 후 진행
- "추가 컨텍스트: <설명>" -- 추가 정보 반영 후 재분석
- "취소" -- 종료

### Step 2: 검토 패널 구성

#### 2a: 페르소나 결정

인수를 분석하여 검토 페르소나를 결정한다. 우선순위:

1. `--personas` 지정 -- 쉼표로 분리하여 페르소나 목록 생성
2. `--preset` 지정 -- 해당 프리셋의 페르소나 목록 사용
3. **둘 다 없으면** -- **Step 2a-R: 페르소나 추천** 실행

#### 2a-R: 페르소나 추천

Step 1의 분석 결과를 기반으로 설계 유형에 최적화된 검토 페르소나를 추천한다.

**추천 알고리즘:**

다음 4가지 차원에서 설계를 분석하고, 각 차원에서 필요한 전문가를 도출한다:

| 분석 차원 | 분석 내용 | 추천 페르소나 예시 |
|-----------|----------|------------------|
| **도메인 전문성** | 설계가 다루는 기술/비즈니스 영역 | 인증 설계 -> 보안 아키텍트, 결제 -> 핀테크 전문가 |
| **이해관계자** | 설계 결과에 영향받는 역할들 | API 설계 -> 프론트엔드 소비자, DB 설계 -> 백엔드 엔지니어 |
| **리스크** | 설계에서 잘못되면 치명적인 영역 | 데이터 모델 -> DBA, 성능 요구사항 -> 성능 엔지니어 |
| **품질 속성** | 설계가 달성해야 할 비기능 요구사항 | 확장성 -> 시스템 아키텍트, 보안 -> 보안 전문가 |

**추천 결과 형식:**

```markdown
## 검토 패널 추천 결과

### 설계 분석 요약
- **설계 유형**: <유형>
- **핵심 도메인**: <도메인>
- **감지된 리스크 영역**: <영역들>

### 추천 패널 (추천순)

| # | 페르소나 | 추천 이유 | 관련 차원 |
|---|---------|----------|----------|
| 1 | <이름> | <이 설계에 왜 필요한지 1문장> | 도메인 전문성 |
| 2 | <이름> | <이 설계에 왜 필요한지 1문장> | 이해관계자 |
| 3 | <이름> | <이 설계에 왜 필요한지 1문장> | 리스크 |
| 4 | <이름> | <이 설계에 왜 필요한지 1문장> | 품질 속성 |

### 고려했지만 제외한 관점
| 페르소나 | 제외 이유 |
|---------|----------|
| <이름> | <이 설계에서는 불필요한 이유> |
```

**추천 원칙:**

- 3-5명을 추천한다 (너무 많으면 검토 비용 증가, 너무 적으면 관점 부족)
- **긴장 관계**를 의도적으로 포함한다 (예: "빠른 구현" vs "확장성 확보" 관점)
- 프리셋에 없는 **설계 맞춤 페르소나**도 자유롭게 추천한다
- 추천 이유를 반드시 명시하여 사용자가 판단할 수 있게 한다

`AskUserQuestion`으로 확인:
- "추천대로 진행" -- 추천된 패널로 Step 2b 진행
- "일부 수정 후 진행" -- 사용자가 추가/제거/변경
- "프리셋으로 대체" -- 프리셋 선택 화면으로 전환
- "취소" -- 종료

#### 2b: 페르소나 프로필 생성

각 페르소나에 대해 검토 프로필을 생성한다:

```markdown
## 검토 패널 구성

| # | 페르소나 | 검토 관점 | 중점 평가 항목 |
|---|---------|-----------|---------------|
| 1 | <이름> | <관점 설명> | <평가 항목 3-4개> |
| 2 | <이름> | <관점 설명> | <평가 항목 3-4개> |
| 3 | <이름> | <관점 설명> | <평가 항목 3-4개> |
```

각 페르소나의 **검토 관점**과 **중점 평가 항목**은 페르소나의 전문 영역과 설계 유형에서 자동 도출한다.

`AskUserQuestion`으로 확인:
- "이대로 진행" -- Step 3으로 진행
- "페르소나 수정" -- 사용자가 프로필을 수정
- "취소" -- 종료

### Step 3: 설계 초안 작성

해당 설계 유형에 맞는 구조화된 설계 초안을 작성한다. 코드베이스 분석 결과와 요구사항을 기반으로 구체적인 설계를 도출한다.

#### 설계 유형별 템플릿

**architecture (아키텍처 설계):**

```markdown
## 아키텍처 설계 초안: <주제>

### 1. 시스템 개요
- 목적 및 범위
- 주요 제약사항

### 2. 컴포넌트 구조
| 컴포넌트 | 책임 | 기술 스택 | 의존성 |
|----------|------|-----------|--------|

### 3. 데이터 흐름
- 주요 데이터 흐름을 시퀀스로 기술

### 4. 의존성 관계
- 컴포넌트 간 의존성 방향과 인터페이스

### 5. 배포 구조
- 배포 단위, 환경별 구성

### 6. 비기능 요구사항 대응
| 품질 속성 | 목표 | 전략 |
|-----------|------|------|
```

**api (API 설계):**

```markdown
## API 설계 초안: <주제>

### 1. API 개요
- 목적, 대상 소비자, 인증 방식

### 2. 엔드포인트 목록
| Method | Path | 설명 | 인증 |
|--------|------|------|------|

### 3. 요청/응답 스키마
- 각 엔드포인트별 요청 본문, 응답 형식, 상태 코드

### 4. 에러 핸들링
| 에러 코드 | 상황 | 응답 형식 |
|-----------|------|-----------|

### 5. 페이지네이션/필터링
- 목록 API의 페이지네이션, 정렬, 필터 전략

### 6. 버전 관리
- API 버전 전략
```

**database (데이터베이스 설계):**

```markdown
## DB 설계 초안: <주제>

### 1. 데이터 모델 개요
- 도메인 설명, 핵심 엔티티

### 2. 테이블/컬렉션 정의
| 테이블명 | 설명 | 주요 컬럼 |
|----------|------|-----------|

### 3. 컬럼 상세
- 각 테이블별 컬럼명, 타입, 제약조건, 설명

### 4. 관계 (ERD)
| 관계 | 유형 | 설명 |
|------|------|------|

### 5. 인덱스 전략
| 테이블 | 인덱스명 | 컬럼 | 용도 |
|--------|----------|------|------|

### 6. 마이그레이션 계획
- 기존 스키마가 있는 경우 마이그레이션 단계
```

**uiux (UI/UX 설계):**

```markdown
## UI/UX 설계 초안: <주제>

### 1. 설계 개요
- 사용자 시나리오, 핵심 인터랙션

### 2. 컴포넌트 트리
- 컴포넌트 계층 구조

### 3. 상태 관리
| 상태 | 위치 | 소유 컴포넌트 | 전파 방식 |
|------|------|-------------|-----------|

### 4. 라우팅
| 경로 | 컴포넌트 | 권한 | 설명 |
|------|----------|------|------|

### 5. 사용자 흐름
- 핵심 사용자 시나리오별 단계 기술

### 6. 반응형/접근성
- 브레이크포인트 전략, 접근성 고려사항
```

**system (시스템 연동 설계):**

```markdown
## 시스템 설계 초안: <주제>

### 1. 시스템 개요
- 연동 목적, 관련 시스템

### 2. 통합 아키텍처
| 시스템 | 역할 | 프로토콜 | 데이터 형식 |
|--------|------|----------|-------------|

### 3. 데이터 흐름
- 시스템 간 데이터 흐름 시퀀스

### 4. 에러 처리 및 복구
| 장애 시나리오 | 감지 방법 | 복구 전략 |
|-------------|----------|-----------|

### 5. 모니터링
- 핵심 메트릭, 알림 조건

### 6. 보안
- 인증/인가, 데이터 암호화, 네트워크 정책
```

설계 초안 작성 후 전체 내용을 표시하고 `AskUserQuestion`으로 확인:
- "이대로 검토 진행" -- Step 4로 진행
- "초안 수정: <수정 사항>" -- 수정 반영 후 다시 표시
- "취소" -- 종료

### Step 4: 전문가 패널 검토

`--parallel` 옵션 여부에 따라 분기한다.

#### 4a: 순차 검토 모드 (기본)

단일 세션에서 각 페르소나의 관점을 순차적으로 적용하여 설계 초안을 검토한다.

각 페르소나별로 다음을 수행:

1. 해당 페르소나의 역할과 전문성을 명시적으로 선언
2. 검토 관점과 중점 평가 항목에 따라 설계 초안을 분석
3. 아래 **검토 결과 형식**에 맞게 결과를 작성

#### 4b: 병렬 검토 모드 (`--parallel`)

에이전트 팀을 사용하여 페르소나별 병렬 검토를 수행한다.

**Step 4b-1: 환경 확인**

```bash
echo $CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS
```

활성화되어 있지 않으면 안내 후 순차 모드로 폴백한다.

**Step 4b-2: 팀 생성**

`TeamCreate`로 팀을 생성한다:
- 팀 이름: `design-review-<주제(kebab-case)>`

**Step 4b-3: 작업 생성 및 팀원 배치**

각 페르소나별로:
1. `TaskCreate`로 검토 작업 생성
2. `Task` 도구로 팀원 생성 (subagent_type: `general-purpose`)
3. `TaskUpdate`로 작업 할당

**팀원 프롬프트 구조:**

```
당신은 [페르소나명]입니다. [전문 영역 설명]

## 검토 대상 설계
[설계 초안 내용]

## 검토 관점
[관점 설명]

## 중점 평가 항목
- [항목 1]
- [항목 2]
- [항목 3]

## 검토 결과 형식
아래 형식에 맞게 검토 결과를 작성하세요.
[검토 결과 형식 참조]

검토가 완료되면 TaskUpdate로 작업을 completed로 표시하세요.
```

**Step 4b-4: 모니터링**

`TaskList`로 진행 상황을 확인하고, 모든 작업이 완료될 때까지 대기한다.

**Step 4b-5: 팀 종료**

모든 검토가 완료되면 팀원에게 `shutdown_request`를 보내고 `TeamDelete`로 정리한다.

#### 검토 결과 형식

각 페르소나의 검토는 다음 형식을 따른다:

```markdown
### [페르소나명] 검토 결과

**총평:** (2-3문장으로 설계에 대한 전체 평가)

**점수:** [1-10] / 10

#### 강점
- [강점 1]
- [강점 2]

#### 개선 필요 사항
| 우선순위 | 설계 영역 | 이슈 | 개선 제안 |
|---------|----------|------|----------|
| 높음 | <영역> | <문제> | <제안> |
| 중간 | <영역> | <문제> | <제안> |
| 낮음 | <영역> | <문제> | <제안> |

#### 질문 사항
- [이 페르소나 관점에서 설계자에게 묻고 싶은 질문]
```

#### 검토 종합

모든 페르소나의 검토가 완료되면 결과를 종합한다:

```markdown
## 설계 검토 종합 리포트

### 페르소나별 점수 요약

| 페르소나 | 점수 | 한줄 총평 |
|---------|------|----------|
| <이름> | <점수>/10 | <총평 요약> |
| **평균** | **<평균>/10** | |

### 공통 강점
- [여러 페르소나가 공통으로 언급한 강점]

### 핵심 개선 사항 (우선순위순)

| 순위 | 이슈 | 관련 페르소나 | 영향도 | 개선 제안 |
|------|------|-------------|--------|----------|
| 1 | <이슈> | <언급한 페르소나들> | 높음/중간/낮음 | <종합 제안> |

### 상충하는 의견
[페르소나 간 의견이 다른 부분이 있으면 정리. 없으면 "없음"]

### 핵심 질문 모음
- [각 페르소나의 질문 중 특히 중요한 것들]
```

`AskUserQuestion`으로 확인:
- "검토 결과를 반영하여 설계 확정" -- Step 5로 진행
- "특정 이슈에 대해 추가 논의" -- 해당 이슈를 심층 분석
- "설계 초안을 대폭 수정 후 재검토" -- Step 3으로 돌아가서 재작성
- "취소" -- 종료

### Step 5: 설계 확정 및 문서 생성

#### 5a: 최종 설계 확정

검토 결과에서 도출된 개선 사항을 반영하여 설계 초안을 최종 확정한다. 확정된 설계를 전체 표시하고 `AskUserQuestion`으로 최종 승인을 받는다:
- "승인. 문서를 생성합니다" -- 5b로 진행
- "추가 수정: <사항>" -- 수정 반영 후 다시 확인
- "취소" -- 종료

#### 5b: 설계 문서 생성

확정된 설계를 문서 파일로 생성한다.

**저장 경로:** `--output`으로 지정된 경로 또는 기본값 `docs/designs/`

**설계 문서 형식:** `docs/designs/<주제(kebab-case)>.md`

```markdown
# <설계 주제> - 설계 명세서

| 항목 | 내용 |
|------|------|
| 작성일 | <날짜> |
| 설계 유형 | <유형> |
| 상태 | 확정 |
| 검토 패널 | <페르소나 목록> |

## 1. 개요
[설계 배경, 목적, 범위]

## 2. 요구사항
[기능/비기능 요구사항 정리]

## 3. 설계 상세
[설계 유형별 상세 내용 - Step 3의 확정된 설계]

## 4. 검토 결과 요약
[Step 4의 종합 리포트 핵심 내용]

## 5. 결정 사항
[주요 설계 결정과 그 근거]

## 6. 향후 고려사항
[현재 범위 밖이지만 추후 검토 필요한 사항]
```

#### 5c: ADR 생성 (선택)

`--adr` 옵션이 있을 때만 실행한다.

기존 ADR 파일을 `Glob`으로 탐색하여 다음 번호를 결정한다.

**ADR 형식:** `docs/decisions/ADR-<번호>-<주제(kebab-case)>.md`

```markdown
# ADR-<번호>: <설계 결정 제목>

## 상태
승인됨

## 컨텍스트
[이 결정이 필요한 배경]

## 결정
[채택한 설계 방향]

## 대안
| 대안 | 장점 | 단점 | 탈락 사유 |
|------|------|------|-----------|

## 결과
[이 결정으로 인한 영향]
```

생성된 파일 경로를 표시한다.

### Step 6: 작업 지시서 생성 (선택)

`--with-plan` 옵션이 있거나, `AskUserQuestion`으로 사용자가 원할 때 실행한다.

#### 6a: feature-planner 존재 여부 확인

`Glob`으로 `**/feature-planner/SKILL.md` 파일을 탐색한다.

#### 6b-1: feature-planner 연계 (존재하는 경우)

feature-planner 스킬을 호출하여 확정된 설계를 기반으로 작업 계획을 자동 생성한다:
- 설계 문서 경로를 feature-planner에 전달
- Phase 분해, 품질 게이트, 롤백 전략 등을 포함한 계획 생성

#### 6b-2: 자체 작업 목록 생성 (존재하지 않는 경우)

feature-planner가 없으면 자체적으로 간단한 구현 단계 목록을 생성한다:

```markdown
## 구현 작업 목록: <주제>

### Phase 1: <단계명>
- [ ] <작업 1>
- [ ] <작업 2>
- [ ] <검증 항목>

### Phase 2: <단계명>
- [ ] <작업 1>
- [ ] <작업 2>
- [ ] <검증 항목>

...
```

결과를 화면에 표시하고 `AskUserQuestion`으로 확인:
- "파일로 저장" -- `docs/plans/PLAN_<주제>.md`로 저장
- "이대로 종료" -- 화면 출력만으로 종료

## 설계 유형별 검토 관점 가이드

각 설계 유형에서 페르소나가 중점적으로 검토해야 할 관점을 정리한다.

### architecture

| 검토 관점 | 핵심 질문 |
|-----------|----------|
| 모듈성 | 컴포넌트 간 결합도가 적절한가? 단일 책임 원칙을 따르는가? |
| 확장성 | 트래픽/데이터 증가 시 수평/수직 확장이 가능한가? |
| 장애 격리 | 한 컴포넌트 장애가 전체 시스템에 전파되는가? |
| 운영성 | 배포, 모니터링, 디버깅이 용이한가? |

### api

| 검토 관점 | 핵심 질문 |
|-----------|----------|
| 일관성 | 네이밍, 응답 형식, 에러 코드가 일관적인가? |
| 사용성 | 소비자 입장에서 직관적이고 사용하기 쉬운가? |
| 보안 | 인증/인가, 입력 검증, rate limiting이 적절한가? |
| 진화 가능성 | 하위 호환성을 유지하며 확장할 수 있는가? |

### database

| 검토 관점 | 핵심 질문 |
|-----------|----------|
| 정규화 | 데이터 중복 없이 적절히 정규화되어 있는가? |
| 쿼리 성능 | 주요 쿼리 패턴에 맞는 인덱스가 설계되었는가? |
| 데이터 무결성 | 제약조건과 관계가 비즈니스 규칙을 반영하는가? |
| 마이그레이션 | 기존 데이터의 안전한 마이그레이션 경로가 있는가? |

### uiux

| 검토 관점 | 핵심 질문 |
|-----------|----------|
| 사용자 경험 | 사용자 흐름이 직관적이고 효율적인가? |
| 컴포넌트 재사용 | 컴포넌트가 적절히 분리되고 재사용 가능한가? |
| 상태 관리 | 상태의 위치와 전파 방식이 합리적인가? |
| 접근성 | WCAG 가이드라인을 충족하는가? |

## 예외사항

### 설계 주제가 없는 경우
"설계 주제를 입력해 주세요. 예: `/design-workshop 사용자 인증 시스템 설계`"를 출력하고 종료한다.

### 설계 유형을 감지할 수 없는 경우
자동 감지 실패 시 설계 유형 목록을 표시하고 `AskUserQuestion`으로 사용자에게 선택을 요청한다.

### 병렬 모드에서 에이전트 팀 미활성화
에이전트 팀 기능이 비활성화되어 있으면 "에이전트 팀 기능(`CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS`)이 비활성화되어 있습니다."를 안내하고 순차 모드로 폴백할지 `AskUserQuestion`으로 확인한다.

### 프로젝트 코드베이스가 없는 경우
코드베이스 탐색 결과가 없으면(빈 프로젝트 등) 요구사항 분석에서 코드베이스 분석을 건너뛰고, 사용자가 제공한 설계 주제만으로 진행한다.

### feature-planner 스킬이 없는 경우 (Step 6)
feature-planner가 없으면 자체적으로 간단한 구현 단계 목록을 생성한다. 에러 없이 독립적으로 완료한다.

## Related Files

| File | Purpose |
|------|---------|
| `custom/workflow/doc-review-panel/SKILL.md` | 페르소나 추천, 패널 검토, 종합 리포트 패턴 참조 |
| `custom/workflow/feature-planner/SKILL.md` | Step 6에서 연계하는 작업 지시서 생성 스킬 |
| `custom/workflow/feature-planner/plan-template.md` | feature-planner 연계 시 사용하는 계획 템플릿 |
| `settings.json` | `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS` 환경 변수 (병렬 모드) |
